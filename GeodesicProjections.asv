%% Pipeline for automated point cloud detection on 'easy' data without embryo noise
% available charts: cylinder & polar charts
% adapted from the Drosophila tutorial of Heemskerk et. al.

%% Overview
% 1. RAW DATA: read in tif and set meta data
% 2. DETECTION: detect point cloud from tif, adjust detectOptions parameters
% 3. SURFACE FITTING: export unaligned! mesh detection with PyMeshLab
% 4. PERMUTATION: read in mesh and permute if necessary 
    % (otherwise the poles will not be at the x-axis of the cylinder map)
% 5. PULLBACK: generate SOI and pullback
    % 5.1 normal pullback for single-layer SOI
    % 5.2 onion pullback for multilayer SOI -> option 'makeIP' 'both'
% 6. VISUALIZE: call pullbacks and pictures with getField('data') or getField('data_MIP')
% 7. SAVE: export SOI to disk 

function GeodesicProjections(tifDir, projectDir, ...
    tifFileName, meshPath, scratchDir, outputDir, ...
    stackSize, timepoint, nLayers, layerDistance)

    % objDir = custom_fullfile(projectDir, 'objFiles');
    
    xp = project.Experiment(projectDir, tifDir);
    
    fileMeta                 = struct();
    fileMeta.dataDir         = tifDir;
    fileMeta.filenameFormat  = tifFileName; 
    fileMeta.timePoints      = timepoint; 
    fileMeta.stackResolution = [1 1 1]; 
    fileMeta.stackSize       = stackSize;
    fileMeta.swapZT          = 0; 
    fileMeta.nChannels       = 1;
    
    expMeta                  = struct();
    expMeta.channelsUsed     = 1;
    expMeta.channelColor     = 1;
    expMeta.description      = 'TriboliumEmbryo';
    expMeta.dynamicSurface   = 0; 
    expMeta.jitterCorrection = 0; 
    expMeta.fitTime          = fileMeta.timePoints(1);
    % detector class that reads in semantic segmentation
    expMeta.detectorType     = 'surfaceDetection.pointCloudDetector';
    % fitter class that reads in mesh generated by Meshlab for cylindrical coordinates
    expMeta.fitterType       = 'surfaceFitting.cylinderMeshWrapper';
    
    xp.setFileMeta(fileMeta);
    xp.setExpMeta(expMeta);
    
    xp.initNew();
    
    xp.loadTime(timepoint); 
    xp.rescaleStackToUnitAspect();

    [~, longAxis] = max(stackSize);
    
    %% Loading mesh

    mesh = read_obj_mod(meshPath);
        
    %% Visualize the Meshlab mesh
    % first argument are the faces of the mesh
    % last argument in trimesh color codes vertices for y-position
    
    % figure;
    % trimesh(mesh.f, mesh.v(:,1), mesh.v(:,2), mesh.v(:,3), mesh.v(:,1));
    % colormap gray
    % axis equal
   
    
    %% Optional: if polar charts are desired
    % the surface is divided into overlapping submeshes starting on seed points

    % user specified seed points = points at the poles with max. distance
    % tips = points directly at poles
    % seeds(1) = find(mesh.v(:, longAxis) == min(mesh.v(:, longAxis)), 1);
    % seeds(2) = find(mesh.v(:, longAxis) == max(mesh.v(:, longAxis)), 1);  

    %% before defining the options, we compute the data sets orientation 
    % since we prefer having a fixed frame of reference. 
    points = mesh.v;
    pc = surfaceDetection.PointCloud(points);
    pc.determineROI(5);
    rotation    = pc.ROI.rotation;
    translation = pc.ROI.translation;
    % disp(translation)
    % disp(rotation)
    
    %% Use case 1: Fitting only for cylinder charts (not! polar charts)
    fitOptions = struct('chartSeeds', [], 'transitionWidth', 100, 'fixAxis',1, ...
        'rotation', rotation,'translation', translation,'fixResolution',1,'resolution',[]);
    xp.setFitOptions(fitOptions);
    xp.fitSurface(mesh);

    % visualize whole mesh
    figure;
    xp.fitter.inspectMesh();
    
    %% Use case 2: Fitting for cylinder AND polar charts
    % fitOptions = struct('diskSeeds', [seeds(1); seeds(2)],'diskRadius', 600); % overlap of submeshes
    % xp.setFitOptions(fitOptions);
    % % marc: "step in" this function
    % xp.fitSurface(mesh);
    % 
    % % visualize submesh(es) when using polar charts
    % % xp.fitter.inspectMesh(1);
    % % view([1 1 1]);
    
    %% Inspect the fit in a cross section
    % inspect fit and point cloud over a cross section in the data. Dimensions 
    % are x,y or z and the value has to be within the corresponding axis range.
    % figure;
    % zval = 151;
    % inspectOptions = struct('dimension','z','value',zval,'pointCloud','b', 'noalign', true);
    % xp.fitter.inspectQuality(inspectOptions, xp.detector, xp.stack);
    
    
    %% Define desired charts
    % automatically calculates transition maps between cylinder charts
    
    % conformal cylinder charts preserve angles
    xp.fitter.setDesiredChart('cylinder1', true); % always needed as basis
    xp.fitter.setDesiredChart('cylinder2', true); % 180Â° rotated
    
    % polar charts preserve distance from poles and angle from ref. axis
    % equidistant_1 is anterior chart, equidistant_2 is posterior chart
    xp.fitter.setDesiredChart('equidistant', true); % optional
    
    xp.generateSOI();
    xp.setFitOptions(xp.fitter.fitOptions) % updates fitOptions
    
    %% Pullback to 2D when using single-layer SOI
    xp.SOI.pullbackStack(xp.stack, [], xp.currentTime);
    
    %% Optional: compute multilayer SOI, as multilayer stack  
    onionOpts = struct('nLayers', nLayers, 'layerDistance', layerDistance, 'sigma', 20, 'makeIP', 'both'); % make maximum intensity projection MIP
    xp.SOI.pullbackStack(xp.stack, [], xp.currentTime, onionOpts);
    
    %% Manual: how to visualize charts
    % the field "data" is the result of the single-layer SOI, 3D -> 2D
    % the field "data_MIP" contains the maximum intensity projection 
    % the field "embedding" contains the embedding function from 2D -> 3D
    
    % charts can be called from a field with patchName and transformName
    % Charts: cylinder1, cylinder2, equidistant_1 and equidistant_2 (mind the _)


%     %% Visualize cylinder chart 1
%     data = xp.SOI.getField('data');
%     % data = xp.SOI.getField('data_MIP'); for multilayer maximum intensity proj
%     data = data(xp.tIdx(xp.currentTime));
%     patchName     = 'cylinder1_index';
%     transformName = 'cylinder1';
%     pb = data.getPatch(patchName).getTransform(transformName).apply{1};
%     
%     figure;
%     % hard-coded annotation for conformal cylinder charts
%     % orientations are only correct when following exact (above) pipeline
%     x = [0.05 0.05];
%     annotation('textarrow',x,[0.91 0.15],'String',''), 
%     annotation('textbox',[.02 .135 .4 .82],'String','anterior','FitBoxToText','on', 'LineStyle', 'none', 'FontSize', 11);
%     annotation('textbox',[.017 0.115 0.04 0.04],'String','posterior','FitBoxToText','on', 'LineStyle', 'none', 'FontSize', 11);
%     
%     imshow(imadjust(pb'),[],'InitialMagnification',66)
%     
%     title('ventral                                                                                       dorsal', 'FontSize', 11)
%     
%     % x axis has to be reversed, to get 'ventral' to be at the left side (as in the data where the embryo is close to the serosa)
%     % the three high-intensity lines are more on the right side
%     set(gca, 'xdir', 'reverse');
%     
% 
%     %% Visualize equidistant chart 1
%     data = xp.SOI.getField('data');
%     data = data(xp.tIdx(xp.currentTime));
%     patchName     = 'equidistant_1_index';
%     transformName = 'equidistant_1';
%     pb = data.getPatch(patchName).getTransform(transformName).apply{1};
%     
%     figure;
%     % hard-coded annotation for conformal cylinder charts
%     % orientations are only correct when following exact (above) pipeline
%     annotation(gcf,'textarrow',...
%     [0.12 0.12], [0.585 0.585],...
%     'String','ventral', 'HeadStyle', 'none', 'LineStyle', 'none',...
%     'FontSize',11, 'TextRotation',90);
%     
%     annotation(gcf,'textarrow',...
%     [0.87 0.87], [0.503 0.503],...
%     'String','dorsal', 'HeadStyle', 'none', 'LineStyle', 'none',...
%     'FontSize',11, 'TextRotation',270);
%     
%     imshow(imadjust(pb'),[],'InitialMagnification',66)
%     
%     title('Anterior Polar Chart', 'FontSize', 11) % das ist korrekt equ_1 ist anterior, links ist ventral
%     
%     % for anterior leave commented, for posterior un-comment (ventral both times on left side)
%     % for anterior: ventral is already on the left side
%     % for posterior: ventral has to be reserved
%     %set(gca, 'xdir', 'reverse');

    
    %% SAVE SOI to disk, can be loaded back and used for other pullbacks
    imwriteOptions = {'tif'};
    saveDir = custom_fullfile(scratchDir, "geodesicProjections");
    
    options = struct('dir',char(saveDir),'imwriteOptions',{imwriteOptions},...
                        'make8bit',false);
    xp.SOI.save(options)
    
    

    % saveFile = "xp_" + uniqueName + ".mat";
    % saveDir2  = custom_fullfile(projectDir, "geodesicProjections", saveFile);
    % save(saveDir2, 'xp')

end
